#ifndef ACTIONS_H_
#define ACTIONS_H_

#include <vector>
#include <memory>
#include <unordered_map>
#include <utility>

#include "event.h"

#include "arrakis.h"
#include "battleplan.h"
#include "enumlabels.h"
#include "gameconstants.h"
#include "gamedata.h"

enum ActionType
{
	ACTION_invalid = 0,

	// pre-init
	ACTION_FACTION_SELECTION,
	GM_ACTION_START_GAME,

	// in-game
	ACTION_PREDICT,
	ACTION_HARKONNEN_REDRAW,
	ACTION_TRAITOR_SELECTION,
	ACTION_FREMEN_PLACEMENT,
	ACTION_BENE_GESSERIT_START_FORCE,
	ACTION_STORM_INITIAL_DIAL,
	ACTION_CHOAM_CHARITY,
	ACTION_BID,
	ACTION_GUILD_SHIPMENT_DECISION,
	ACTION_SHIP,
	ACTION_INTRUSION_RESPONSE,
	ACTION_ACCOMPANY_SHIPMENT,
	ACTION_MOVE,
	ACTION_BATTLE_SELECTION,
	ACTION_COMMIT_BATTLE_PLAN,
};
using EnumActionType = Enum<ActionType, ACTION_invalid>;

class Action;

class ActionFactory
{
public:
	static std::unique_ptr<Action> create(Faction, const std::string&);
};

/**
 * @class Action
 * Base class for all actions.
 * Actions are generated by the factions to express intent of something to happen.
 * They may be send over network as JSON document by a remote player.
 * They also may be constructed directly by a local bot or any kind of code.
 *
 * Actions can be further divided in:
 * - normal player actions, which subclass directly from @ref Action
 * - game master actions, which can only be executed by actions considered a game master
 *
 * All actions contain a @ref from and @ref type attribute which help the game logic to determine its validity.
 *
 * Especially the @ref from attribute needs special handling:
 * - Actions generated locally, can use the appropriate subclass-constructor directly.
 *   Thus, set any Faction without restrictions
 *
 * - Actions in JSON document form, possibly were send by a remote peer.
 *   The @ref ActionFactory is responsible for creating the right action.
 *
 *   If the document contains a "from" member, it is ignored.
 *   Instead, a dedicated parameter @ref aFrom takes priority.
 *   This is done because, a remote peer may have manipulated the @ref from attribute.
 *
 * @warning Subclass implementations of the JSON document constructor should <b>never use<b/> any "from" member from the document,
 * but instead require a dedicated constructor argument.
 * De-Serialized actions may be send from an untrusted source and may be manipulated.
 * Therefore the @ref mFrom member needs to be set by a local source
 *
 */
class Action : public Event
{
public:
	static constexpr int VERSION = 1;

	static ActionType parseActionType(const std::string& json);

	virtual ~Action() {}
	virtual bool isGMAction() const noexcept { return false; }

	Faction from() const noexcept { return mFrom; }
	ActionType type() const noexcept {return mType; }
	const char* label() { return EnumActionType::label(mType); }
protected:
	Action(Faction aFrom, ActionType aType)
	: Event(ET_ACTION),
	  mFrom(aFrom), mType(aType)
	{
	}

private:
	Faction mFrom;     /// json member "from"
	ActionType mType;  /// json member "type"
};

class GMAction : public Action
{
protected:
	GMAction(Faction aFrom, ActionType aType)
	: Action(aFrom, aType)
	{
	}

	virtual bool isGMAction() const noexcept { return true; }
};

class GmActionStartGame : public GMAction
{
public:
	explicit GmActionStartGame(Faction aFrom)
	: GMAction(aFrom, GM_ACTION_START_GAME)
	{
	}

	GmActionStartGame(Faction aFrom, const std::string&)
	: GMAction(aFrom, GM_ACTION_START_GAME)
	{
	}
};

class ActionFactionSelection : public Action
{
public:
	/// @attention special case: this action is needed for the remote player to select a faction
	explicit ActionFactionSelection(const std::string& json)
	: Action(parseFrom(json), ACTION_FACTION_SELECTION)
	{
	}

private:
	static Faction parseFrom(const std::string& json);
};

class ActionPrediction : public Action
{
public:
	ActionPrediction(Faction aFrom, Faction aWinner, int aRound);
	ActionPrediction(Faction aFrom, const std::string& json);

	Faction winner() const noexcept { return mWinner; }
	int     round()  const noexcept { return mRound; }

private:
	Faction mWinner;
	int mRound;
};

class ActionTraitorSelection : public Action
{
public:
	ActionTraitorSelection(Faction aFrom, Leader::Id aSelection);
	ActionTraitorSelection(Faction aFrom, const std::string& json);

	const Leader::Id selection;
};

class ActionFremenPlacement : public Action
{
public:
	ActionFremenPlacement(Faction aFrom, const std::vector<Placement>& aPlacements);
	ActionFremenPlacement(Faction aFrom, const std::string& json);

	const std::vector<Placement> placements;
};

class ActionHarkonnenRedraw : public Action
{
public:
	ActionHarkonnenRedraw(Faction aFrom, bool aValue)
	: Action(aFrom, ACTION_HARKONNEN_REDRAW),
	  redraw(aValue)
	{
	}

	const bool redraw;
};

class ActionBeneGesseritStartingForce : public Action
{
public:
	ActionBeneGesseritStartingForce(Faction aFrom, AreaId aWhere)
	: Action(aFrom, ACTION_BENE_GESSERIT_START_FORCE),
	  where(aWhere)
	{
	}

	const AreaId where;
};

class ActionStormInitialDial : public Action
{
public:
	ActionStormInitialDial(Faction aFrom, int aDial)
	: Action(aFrom, ACTION_STORM_INITIAL_DIAL),
	  dial(aDial)
	{
	}

	const int dial;
};

class ActionChoamCharity : public Action
{
public:
	ActionChoamCharity(Faction aFrom, bool aNeed)
	: Action(aFrom, ACTION_CHOAM_CHARITY),
	  need(aNeed)
	{
	}

	const bool need;
};

class ActionBid : public Action
{
public:
	enum Type
	{
		RAISE,
		PASS,
		KARAMA_BUY
	};

	ActionBid(Faction aFrom, int aBid)
	: Action(aFrom, ACTION_BID),
	  type(RAISE),
	  bid(aBid)
	{
	}

	ActionBid(Faction aFrom, Type aType)
	: Action(aFrom, ACTION_BID),
	  type(aType),
	  bid(0)
	{
	}

	const Type type;
	const int bid;
};

class ActionGuildShipmentDecision : public Action
{
public:
	ActionGuildShipmentDecision(Faction aFrom, bool aShipNow)
	: Action(aFrom, ACTION_GUILD_SHIPMENT_DECISION),
	  shipNow(aShipNow)
	{
	}

	const bool shipNow;
};

class ActionShip : public Action
{
public:
	enum InvertShipment { TRUE };

	/**
	 * perform a standard shipment.
	 * forces are taken from reserve
	 * @note this event is also applicable for fremen shipments
	 */
	ActionShip(Faction aFaction, Placement aTo)
	: Action(aFaction, ACTION_SHIP),
	  to(aTo), fromArea(AreaId::INVALID), fromReserve(true), inverted(false)
	{
	}

	/**
	 * perform an on-planet shipment.
	 * Usually this is allowed for the guild player only
	 */
	ActionShip(Faction aFaction, AreaId aFrom, Placement aTo)
	: Action(aFaction, ACTION_SHIP),
	  to(aTo), fromArea(aFrom), fromReserve(false), inverted(false)
	{
	}

	/**
	 * perform a very special FROM planet TO reserve shipment.
	 * Usually this is allowed for the guild player only
	 */
	ActionShip(Faction aFaction, Placement aFrom, InvertShipment)
	: Action(aFaction, ACTION_SHIP),
	  to(aFrom), fromArea(AreaId::INVALID), fromReserve(true), inverted(true)
	{
	}

	const Placement to;
	const AreaId fromArea;
	const bool fromReserve;
	const bool inverted;
};

class ActionIntrusionReaction : public Action
{
public:
	ActionIntrusionReaction(Faction aFrom, bool aDisengage)
	: Action(aFrom, ACTION_INTRUSION_RESPONSE),
	  disengage(aDisengage)
	{
	}

	bool disengage;
};

class ActionAccompanyDecision : public Action
{
public:
	enum Decision
	{
		PASS               = 0,
		ACCOMPANY_SHIPMENT = 1,
		SEND_TO_POLAR_SINK = 2
	};

	ActionAccompanyDecision(Faction aFrom, Decision aDecision)
	: Action(aFrom, ACTION_ACCOMPANY_SHIPMENT),
	  decision(aDecision)
	{
	}

	const Decision decision;
};

class ActionMove : public Action
{
public:
	enum AsAdvisor { TRUE };

	ActionMove(Faction aFaction, AreaId aFrom, Placement aTo, bool aUseHajr = false)
	: Action(aFaction, ACTION_MOVE),
	  to(aTo), fromArea(aFrom), useHajr(aUseHajr), asAdvisor(false)
	{
	}

	ActionMove(Faction aFaction, AreaId aFrom, Placement aTo, AsAdvisor, bool aUseHajr = false)
	: Action(aFaction, ACTION_MOVE),
	  to(aTo), fromArea(aFrom), useHajr(aUseHajr), asAdvisor(true)
	{
	}

	const Placement to;
	const AreaId fromArea;
	const bool useHajr;
	const bool asAdvisor;
};

class ActionBattleSelection : public Action
{
public:

	/**
	 * @brief Select whom and where to fight next.
	 * Only the ambiguous portions are evaluated by the game logic. All other parts are ignored.
	 */
	ActionBattleSelection(Faction aFrom, Faction aEnemy, AreaId aWhere)
	: Action(aFrom, ACTION_BATTLE_SELECTION),
	  where(aWhere), who(aEnemy)
	{
	}

	/**
	 * Select whom to fight next.
	 * This is only possible if the area is unambiguous.
	 */
	ActionBattleSelection(Faction aFrom, Faction aEnemy)
	: Action(aFrom, ACTION_BATTLE_SELECTION),
	  where(AreaId::INVALID), who(aEnemy)
	{
	}
	
	/**
	 * Select where to fight next.
	 * This is only possible if the enemy is unambiguous.
	 */
	ActionBattleSelection(Faction aFrom, AreaId aWhere)
	: Action(aFrom, ACTION_BATTLE_SELECTION),
	  where(aWhere), who(Faction::none())
	{
	}

	const AreaId where;
	const Faction who;
};

class ActionCommitBattlePlan : public Action
{
public:
	ActionCommitBattlePlan(Faction aFrom, const BattlePlan& aPlan)
		: Action(aFrom, ACTION_COMMIT_BATTLE_PLAN),
		plan(aPlan.copyContent())
	{
	}

	const BattlePlan::Data plan;
};

#endif /* ACTIONS_H_ */
